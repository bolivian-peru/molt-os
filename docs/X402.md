# x402 — OS-Native Micropayments

Last updated: 2026-02-23

osModa already has crypto wallets (osmoda-keyd). x402 is the HTTP payment protocol that lets the OS spend those wallets autonomously, within policy limits, to pay for API services.

---

## What x402 is

x402 is an open HTTP payment protocol by Coinbase. When a server wants payment for a resource, it returns `402 Payment Required` with a `PAYMENT-REQUIRED` header. The client signs a USDC payment (ERC-3009 `transferWithAuthorization`), retries with a `PAYMENT-SIGNATURE` header, and gets access.

**The flow:**
```
Client → GET /api/data
Server ← 402 Payment Required
         PAYMENT-REQUIRED: { "amount": "0.001", "asset": "USDC", "chain": "base" }

Client signs USDC transferWithAuthorization with ETH key
Client → GET /api/data
         PAYMENT-SIGNATURE: { signed payment payload }
Server verifies on-chain → grants access
```

Supports: USDC on Base (primary), any EIP-3009 token on any EVM chain.
Cost: $0.001–$0.01 per call typical. Near-zero gas (ERC-3009 is gasless transfers).

---

## Why this belongs in the OS

Most x402 implementations are application-level — each app handles the 402 flow itself. osModa makes it **OS-level**: any request from any daemon or sandboxed app that hits a 402 is automatically paid, within policy, with no app-level code.

The pieces already exist:
- **osmoda-keyd** — ETH wallet with AES-256-GCM encrypted keys
- **osmoda-keyd policy engine** — daily spend limits, per-domain allowlists, fixed-point arithmetic
- **osmoda-egress** — the HTTP proxy every daemon and Ring 1/2 app routes through
- **agentd ledger** — hash-chained audit trail for every payment

**osmoda-egress becomes the x402 middleware.** One place. All traffic. Zero per-app code.

---

## How it works

```
osmoda-mesh, routines, or Ring 1 app
  │ HTTP request
  ▼
osmoda-egress (HTTP CONNECT proxy)
  │ forward request
  ▼
External API server
  ← 402 Payment Required
     PAYMENT-REQUIRED: base64({
       amount: "0.001",
       asset: "USDC",
       chain: "base",
       payTo: "0x...",
       expiry: 1234567890
     })
  │
  ▼
osmoda-egress: intercepts 402
  │ POST /x402/sign to osmoda-keyd
  │ { domain, amount, asset, chain, payTo, expiry }
  ▼
osmoda-keyd:
  1. Check policy — is api.example.com in allowlist?
  2. Check daily limit — is $0.001 within remaining budget?
  3. Sign: ERC-3009 transferWithAuthorization with ETH wallet
  4. Log to agentd: x402.payment.signed
  5. Return signed payload
  │
  ▼
osmoda-egress: retry original request
  PAYMENT-SIGNATURE: { signed payload }
  │
  ▼
External API: verify → return 200 + data
  │
  ▼
osmoda-egress: log x402.payment.settled to agentd
  forward response to caller
```

The calling daemon sees a normal 200 response. It has no idea a payment happened. The entire x402 flow is transparent.

---

## What changes in the code

### osmoda-keyd — two new endpoints

```
POST /x402/sign
  Request: { domain, amount_usd, asset, chain, pay_to, expiry, wallet_id? }
  Response: { signature: hex, wallet_address: "0x...", signed_at: timestamp }

  Policy check: same engine as /wallet/sign
  - domain must be in allowlist (or policy must be open)
  - amount must be within daily x402 budget (separate from wallet/send budget)
  - signs ERC-3009 transferWithAuthorization

GET /x402/policy
  Returns current x402 policy state: daily_budget, spent_today, allowed_domains[]
```

**NixOS config:**
```nix
services.osmoda.keyd.x402 = {
  enable = true;
  defaultWalletLabel = "x402-spending";  # which wallet to use
  dailyBudgetUsd = "1.00";               # max $1/day via x402
  allowedDomains = [                     # which domains can be paid
    "api.openai.com"
    "api.anthropic.com"
    "api.quicknode.com"
  ];
};
```

### osmoda-egress — x402 middleware

Current egress is a domain-allowlist HTTP CONNECT proxy. Addition:

1. Intercept 402 responses (not forwarded to caller)
2. Parse `PAYMENT-REQUIRED` header
3. Call `POST /x402/sign` on keyd via Unix socket
4. On success: retry original request with `PAYMENT-SIGNATURE`
5. On policy rejection: forward the 402 to caller (let it decide)
6. Log: `x402.payment.attempt`, `x402.payment.settled`, `x402.payment.rejected`

**NixOS config:**
```nix
services.osmoda.egress.x402 = {
  enable = true;
  keydSocket = "/run/osmoda/keyd.sock";
  maxRetries = 1;  # don't pay more than once per request
};
```

### No changes needed elsewhere

osmoda-bridge gets two new tools automatically (reflect keyd's new endpoints):

```
x402_policy    — view current x402 spending + limits
x402_configure — update allowed domains or daily budget
```

The AI can tell you: "You spent $0.34 on x402 API calls today, mostly to api.quicknode.com."

---

## User experience

**Setup:**
```
"Enable x402 payments, budget $1 per day, allow payments to QuickNode"
→ AI: enables x402 in keyd config, sets domain allowlist, sets budget
→ nixos-rebuild switch
→ any QuickNode API that returns 402 is now auto-paid
```

**Checking spend:**
```
"How much have I spent on API payments today?"
→ AI calls x402_policy
→ "You've spent $0.34 of your $1.00 daily x402 budget:
   - api.quicknode.com: $0.28 (14 calls)
   - scrapling-mcp: $0.06 (6 premium bypasses)"
```

**Audit trail in ledger:**
```
x402.payment.signed  — keyd signed a payment
x402.payment.settled — egress confirmed delivery
x402.budget.exceeded — domain rejected (over limit)
```

---

## Why keyd is the right place for signing (not egress)

osmoda-egress runs as a less-privileged systemd unit. osmoda-keyd is the key custodian — it owns the signing keys, the policy engine, and the spend limits. Egress should never see the private key. It asks keyd to sign and gets back a signature. Key material never leaves keyd.

This mirrors how keyd handles `/wallet/sign`: the caller describes what to sign, keyd decides whether policy allows it, keyd signs with the key it holds, keyd returns only the signature.

---

## MCP integration

When the Scrapling MCP server (or any MCP server managed by osmoda-mcpd) makes an outbound request through the egress proxy and hits a 402, x402 kicks in transparently. The MCP server's tool call succeeds, the payment was made, the ledger has a record.

MCP + x402 + keyd = the AI can access paid APIs the same way it accesses free ones. Within policy. With full audit trail. No manual top-ups, no API keys to manage.

---

## Implementation order

1. `keyd`: `POST /x402/sign` + `GET /x402/policy` (~100 LOC in `api.rs`)
2. `keyd`: x402 policy fields in `PolicyFile` struct (~20 LOC in `policy.rs`)
3. `keyd` NixOS options for x402 (~20 LOC in `osmoda.nix`)
4. `egress`: 402 intercept + keyd call + retry (~80 LOC in `main.rs`)
5. `egress` NixOS options for x402 (~10 LOC in `osmoda.nix`)
6. bridge: `x402_policy` + `x402_configure` tools (~40 LOC in `index.ts`)
7. `templates/TOOLS.md`: document x402 tools
8. Tests: policy check, sign roundtrip, budget exceeded case (~30 LOC)

**Total: ~300 LOC.** Sprint 2.
